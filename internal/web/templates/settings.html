{{define "content"}}
  <section class="hero-copy">
    <h2 class="section-title">Settings</h2>
    <p class="muted">Tune which activities are hidden and keep your account tidy.</p>
    {{if .Message}}
      <div class="card">
        <strong>{{.Message}}</strong>
      </div>
    {{end}}
  </section>

  <section class="settings-stack">
    <article class="card settings-section">
      <div class="section-head">
        <div>
          <h3>Hide activity rules</h3>
          <p class="muted">Rules are evaluated after stats are computed. If multiple rules match, any hide wins.</p>
        </div>
        <span class="pill">JSON-backed</span>
      </div>
      <div class="rule-list">
        {{if .Rules}}
          {{range .Rules}}
            <div class="rule-row">
              <div class="rule-main">
                <div class="rule-title">
                  <strong>{{.Name}}</strong>
                  {{if .IsLegacy}}<span class="pill muted">Legacy</span>{{end}}
                </div>
                <span class="muted">{{.Description}}</span>
              </div>
              <div class="rule-actions">
                <form method="post" action="/activities/settings" class="rule-action">
                  <input type="hidden" name="action" value="toggle-rule" />
                  <input type="hidden" name="rule_id" value="{{.ID}}" />
                  <label class="toggle">
                    <input type="checkbox" name="enabled" {{if .Enabled}}checked{{end}} />
                    Status: {{boolLabel .Enabled}}
                  </label>
                  <button class="btn secondary small" type="submit">Update</button>
                </form>
                <form method="post" action="/activities/settings" class="rule-action">
                  <input type="hidden" name="action" value="delete-rule" />
                  <input type="hidden" name="rule_id" value="{{.ID}}" />
                  <button class="btn secondary small" type="submit">Delete rule</button>
                </form>
              </div>
            </div>
          {{end}}
        {{else}}
          <div class="rule-row">
            <div class="rule-main">
              <strong>No rules yet</strong>
              <span class="muted">Add a rule below to start hiding activities.</span>
            </div>
          </div>
        {{end}}
      </div>
    </article>

    <article class="card settings-section">
      <div class="section-head rule-editor-head">
        <div>
          <h3 class="rule-editor-title">Rule spec and JSON input</h3>
          <p class="muted">Copy the spec into an LLM, ask for a rule, then paste the JSON here.</p>
        </div>
      </div>
      <form method="post" action="/activities/settings" class="rule-builder" id="rule-json-form">
        <input type="hidden" name="action" value="add-rule" />
        <input type="hidden" name="name" id="rule-name" value="Custom JSON rule" />
        <div class="builder-stack">
          <div class="builder-section">
            <div class="builder-actions">
              <h4>Spec for LLM</h4>
              <button type="button" class="btn secondary small" id="rule-spec-copy">Copy spec</button>
            </div>
            <textarea id="rule-spec" class="rule-spec-area" readonly spellcheck="false">Loading spec...</textarea>
            <div class="field-help">Templates are included in this spec.</div>
          </div>

          <div class="builder-section">
            <h4>Rule JSON input</h4>
            <textarea name="condition" id="rule-json-input" class="rule-json-input" spellcheck="false" placeholder='{"match":"all","conditions":[{"metric":"activity_type","op":"eq","values":["Workout"]}],"action":{"type":"hide","override":{"one_in":10}}}'></textarea>
            <div class="rule-error" id="rule-json-error"></div>
            <div class="builder-preview">
              <div class="muted">Normalized JSON preview</div>
              <pre id="rule-json-preview">{}</pre>
            </div>
          </div>

          <div class="builder-section">
            <label class="toggle">
              <input type="checkbox" name="enabled" checked />
              Enabled
            </label>
          </div>

          <button class="btn small" type="submit" id="rule-submit">Add rule</button>
        </div>
        <noscript>
          <p class="muted">Paste valid JSON into Rule JSON input, then submit.</p>
        </noscript>
      </form>
    </article>

    <article class="card settings-section">
      <h3>Strava connection</h3>
      <p class="muted">Manage your Strava account connection. Reconnect if you're having permission issues.</p>
      <div class="settings-actions">
        <a class="btn secondary" href="/connect/strava?force=1">Reconnect Strava</a>
        <form method="post" action="/activities/settings">
          <input type="hidden" name="action" value="sign-out" />
          <button class="btn secondary" type="submit">Sign out</button>
        </form>
      </div>
    </article>

    <article class="card settings-section">
      <h3>Danger zone</h3>
      <p class="muted">Delete your data, revoke tokens, and stop processing.</p>
      <form method="post" action="/activities/settings" class="rule">
        <input type="hidden" name="action" value="delete-account" />
        <label>
          <div class="muted">Type "delete" to confirm</div>
          <input name="confirm" placeholder="delete" />
        </label>
        <button class="btn danger" type="submit">Delete account</button>
      </form>
    </article>
  </section>

  <script type="application/json" id="rules-metadata">{{.RulesMetaJSON}}</script>
  <script>
    (function() {
      const metaEl = document.getElementById('rules-metadata');
      if (!metaEl) return;
      let meta;
      try {
        meta = JSON.parse(metaEl.textContent);
      } catch (err) {
        meta = { metrics: [], operators: {} };
      }
      const metrics = Array.isArray(meta.metrics) ? meta.metrics : [];
      const operatorsByType = meta && meta.operators && typeof meta.operators === 'object' ? meta.operators : {};
      const metricsByID = new Map(metrics.map(metric => [metric.id, metric]));

      const formEl = document.getElementById('rule-json-form');
      if (!formEl) return;
      const specEl = document.getElementById('rule-spec');
      const copySpecBtn = document.getElementById('rule-spec-copy');
      const jsonInputEl = document.getElementById('rule-json-input');
      const errorEl = document.getElementById('rule-json-error');
      const previewEl = document.getElementById('rule-json-preview');
      const submitBtn = document.getElementById('rule-submit');
      const nameEl = document.getElementById('rule-name');

      const templates = [
        {
          id: 'short-rides',
          name: 'Hide short rides',
          description: 'Hide rides under 5 km.',
          tags: ['Ride', '<5km'],
          rule: {
            match: 'all',
            conditions: [
              { metric: 'activity_type', op: 'in', values: ['Ride', 'VirtualRide', 'EBikeRide', 'GravelRide'] },
              { metric: 'distance_m', op: 'lt', values: [5000] }
            ],
            action: { type: 'hide' }
          }
        },
        {
          id: 'short-walks',
          name: 'Hide short walks',
          description: 'Hide walks under 15 minutes.',
          tags: ['Walk', '<15m'],
          rule: {
            match: 'all',
            conditions: [
              { metric: 'activity_type', op: 'eq', values: ['Walk'] },
              { metric: 'moving_time_s', op: 'lt', values: [900] }
            ],
            action: { type: 'hide' }
          }
        },
        {
          id: 'stop-heavy',
          name: 'Hide stop-heavy activities',
          description: 'Hide activities with more than 8 stops.',
          tags: ['Stops', '>8'],
          rule: {
            match: 'all',
            conditions: [
              { metric: 'stop_count', op: 'gt', values: [8] }
            ],
            action: { type: 'hide' }
          }
        },
        {
          id: 'workouts',
          name: 'Hide workouts, unmute every 10th',
          description: 'Hide Workout activities but keep one out of every 10 visible.',
          tags: ['Workout', '1/10 visible'],
          rule: {
            match: 'all',
            conditions: [
              { metric: 'activity_type', op: 'eq', values: ['Workout'] }
            ],
            action: { type: 'hide', override: { one_in: 10 } }
          }
        }
      ];

      function findOperator(valueType, opID) {
        const list = Array.isArray(operatorsByType[valueType]) ? operatorsByType[valueType] : [];
        for (let i = 0; i < list.length; i += 1) {
          if (list[i].id === opID) {
            return list[i];
          }
        }
        return null;
      }

      function operatorValueHint(operator) {
        if (!operator) return "one or more values";
        if (operator.value_mode === "single") {
          return "exactly 1 value";
        }
        if (operator.value_mode === "range") {
          return "exactly 2 values";
        }
        if (operator.value_mode === "list") {
          return "one or more values";
        }
        if (operator.value_count === 1) {
          return "exactly 1 value";
        }
        if (operator.value_count === 2) {
          return "exactly 2 values";
        }
        return "one or more values";
      }

      function buildSpecText() {
        const lines = [];
        lines.push("Return one valid JSON object for a weirdstats hide rule.");
        lines.push("Return JSON only. No markdown fences, no extra text.");
        lines.push("");
        lines.push("Rule object shape:");
        lines.push("{");
        lines.push('  "match": "all" | "any",');
        lines.push('  "conditions": [');
        lines.push('    { "metric": "metric_id", "op": "operator_id", "values": [value1, value2] }');
        lines.push("  ],");
        lines.push('  "action": { "type": "hide", "override": { "one_in": 10 } }');
        lines.push("}");
        lines.push("");
        lines.push("Validation rules:");
        lines.push("- conditions must include at least one item.");
        lines.push('- action.type must be "hide".');
        lines.push("- action.override.one_in is optional and must be an integer >= 2 when present.");
        lines.push("- action.allow.one_in is also accepted as a legacy alias.");
        lines.push("- if both override.one_in and allow.one_in are present, they must match.");
        lines.push("");
        lines.push("Operators by metric type:");
        Object.keys(operatorsByType).sort().forEach(function(valueType) {
          const operators = Array.isArray(operatorsByType[valueType]) ? operatorsByType[valueType] : [];
          const details = operators.map(function(op) {
            return op.id + " (" + operatorValueHint(op) + ")";
          });
          lines.push("- " + valueType + ": " + details.join(", "));
        });
        lines.push("");
        lines.push("Available metrics:");
        metrics.forEach(function(metric) {
          const unitText = metric.unit ? ", unit " + metric.unit : "";
          const label = metric.label || metric.id;
          let line = "- " + metric.id + " (" + metric.type + unitText + "): " + label;
          if (metric.description) {
            line += ". " + metric.description;
          }
          if (metric.example) {
            line += " Example: " + metric.example + ".";
          }
          if (metric.type === "enum" && Array.isArray(metric.enum) && metric.enum.length) {
            line += " Allowed values: " + metric.enum.join(", ") + ".";
          }
          lines.push(line);
        });
        lines.push("");
        lines.push("Templates:");
        templates.forEach(function(template, index) {
          lines.push((index + 1) + ". " + template.name + ": " + template.description);
          lines.push("  " + JSON.stringify(template.rule, null, 2).split("\n").join("\n  "));
        });
        lines.push("");
        lines.push("Generate a new rule JSON that follows this spec.");
        return lines.join("\n");
      }

      function normalizeRule(rawRule) {
        const safeRule = rawRule && typeof rawRule === "object" && !Array.isArray(rawRule) ? rawRule : {};
        const safeAction = safeRule.action && typeof safeRule.action === "object" ? safeRule.action : {};
        const safeOverride = safeAction.override && typeof safeAction.override === "object" ? safeAction.override : null;
        const safeAllow = safeAction.allow && typeof safeAction.allow === "object" ? safeAction.allow : null;
        const normalized = {
          match: typeof safeRule.match === "string" && safeRule.match ? safeRule.match : "all",
          conditions: Array.isArray(safeRule.conditions) ? safeRule.conditions.map(function(condition) {
            const safeCondition = condition && typeof condition === "object" && !Array.isArray(condition) ? condition : {};
            return {
              metric: typeof safeCondition.metric === "string" ? safeCondition.metric : "",
              op: typeof safeCondition.op === "string" ? safeCondition.op : "",
              values: Array.isArray(safeCondition.values) ? safeCondition.values : []
            };
          }) : [],
          action: {
            type: typeof safeAction.type === "string" && safeAction.type ? safeAction.type : "hide"
          }
        };
        if (safeOverride && safeOverride.one_in !== undefined && safeOverride.one_in !== null && safeOverride.one_in !== "") {
          const oneIn = Number(safeOverride.one_in);
          normalized.action.override = { one_in: Number.isInteger(oneIn) ? oneIn : safeOverride.one_in };
        }
        if (safeAllow && safeAllow.one_in !== undefined && safeAllow.one_in !== null && safeAllow.one_in !== "") {
          const oneIn = Number(safeAllow.one_in);
          normalized.action.allow = { one_in: Number.isInteger(oneIn) ? oneIn : safeAllow.one_in };
          if (!normalized.action.override) {
            normalized.action.override = { one_in: normalized.action.allow.one_in };
          }
        }
        return normalized;
      }

      function canonicalizeRule(rule) {
        const out = JSON.parse(JSON.stringify(rule));
        if (!out.action || typeof out.action !== "object") {
          return out;
        }
        if (!out.action.override && out.action.allow && out.action.allow.one_in !== undefined) {
          out.action.override = { one_in: out.action.allow.one_in };
        }
        delete out.action.allow;
        return out;
      }

      function validateRule(rule) {
        if (!rule || typeof rule !== "object" || Array.isArray(rule)) {
          return "Rule must be a JSON object.";
        }
        if (rule.match !== "all" && rule.match !== "any") {
          return 'match must be "all" or "any".';
        }
        if (!Array.isArray(rule.conditions) || rule.conditions.length === 0) {
          return "At least one condition is required.";
        }
        if (!rule.action || typeof rule.action !== "object") {
          return "action must be an object.";
        }
        if (rule.action.type && rule.action.type !== "hide") {
          return 'action.type must be "hide".';
        }
        if (rule.action.override && rule.action.override.one_in !== undefined) {
          const oneIn = Number(rule.action.override.one_in);
          if (!Number.isInteger(oneIn) || oneIn < 2) {
            return "action.override.one_in must be an integer >= 2.";
          }
          rule.action.override.one_in = oneIn;
        }
        if (rule.action.allow && rule.action.allow.one_in !== undefined) {
          const oneIn = Number(rule.action.allow.one_in);
          if (!Number.isInteger(oneIn) || oneIn < 2) {
            return "action.allow.one_in must be an integer >= 2.";
          }
          rule.action.allow.one_in = oneIn;
        }
        if (rule.action.override && rule.action.allow &&
            rule.action.override.one_in !== undefined &&
            rule.action.allow.one_in !== undefined &&
            rule.action.override.one_in !== rule.action.allow.one_in) {
          return "action.override.one_in and action.allow.one_in must match when both are set.";
        }
        for (let i = 0; i < rule.conditions.length; i += 1) {
          const condition = rule.conditions[i];
          if (!condition || typeof condition !== "object" || Array.isArray(condition)) {
            return "Condition " + (i + 1) + " must be an object.";
          }
          if (!condition.metric) {
            return "Condition " + (i + 1) + ": metric is required.";
          }
          if (!condition.op) {
            return "Condition " + (i + 1) + ": op is required.";
          }
          if (!Array.isArray(condition.values)) {
            return "Condition " + (i + 1) + ": values must be an array.";
          }
          if (metricsByID.size === 0) {
            if (condition.values.length === 0) {
              return "Condition " + (i + 1) + ": values cannot be empty.";
            }
            continue;
          }
          const metric = metricsByID.get(condition.metric);
          if (!metric) {
            return "Condition " + (i + 1) + ": unknown metric " + condition.metric + ".";
          }
          const operator = findOperator(metric.type, condition.op);
          if (!operator) {
            return "Condition " + (i + 1) + ": invalid operator " + condition.op + " for metric type " + metric.type + ".";
          }
          if (operator.value_count === 1 && condition.values.length !== 1) {
            return "Condition " + (i + 1) + ": operator " + condition.op + " expects exactly 1 value.";
          }
          if (operator.value_count === 2 && condition.values.length !== 2) {
            return "Condition " + (i + 1) + ": operator " + condition.op + " expects exactly 2 values.";
          }
          if (operator.value_count === -1 && condition.values.length < 1) {
            return "Condition " + (i + 1) + ": operator " + condition.op + " expects one or more values.";
          }
          for (let j = 0; j < condition.values.length; j += 1) {
            const value = condition.values[j];
            if (metric.type === "number") {
              if (typeof value !== "number" || !Number.isFinite(value)) {
                return "Condition " + (i + 1) + ": numeric metric " + metric.id + " requires numeric values.";
              }
            } else if (metric.type === "enum") {
              if (typeof value !== "string") {
                return "Condition " + (i + 1) + ": enum metric " + metric.id + " requires string values.";
              }
            }
          }
        }
        return "";
      }

      function deriveRuleName(rule) {
        if (!rule || !Array.isArray(rule.conditions) || rule.conditions.length === 0) {
          return "Custom JSON rule";
        }
        const first = rule.conditions[0];
        const metric = metricsByID.get(first.metric);
        const metricLabel = metric ? metric.label : first.metric;
        const operator = metric ? findOperator(metric.type, first.op) : null;
        const operatorLabel = operator ? operator.label : first.op;
        const prefix = rule.match === "any" ? "Hide when any" : "Hide when";
        const oneIn = rule.action && rule.action.override && rule.action.override.one_in;
        const overrideSuffix = Number.isInteger(oneIn) && oneIn >= 2 ? " (1 in " + oneIn + " visible)" : "";
        const name = [prefix, metricLabel, operatorLabel].filter(Boolean).join(" ") + overrideSuffix;
        return name ? name.slice(0, 120) : "Custom JSON rule";
      }

      function renderValidation() {
        if (!jsonInputEl) {
          return { ok: false, rule: null };
        }
        const raw = jsonInputEl.value.trim();
        if (!raw) {
          if (errorEl) errorEl.textContent = "Paste rule JSON to validate.";
          if (previewEl) previewEl.textContent = "{}";
          if (nameEl) nameEl.value = "Custom JSON rule";
          if (submitBtn) submitBtn.disabled = true;
          return { ok: false, rule: null };
        }
        let parsed;
        try {
          parsed = JSON.parse(raw);
        } catch (err) {
          if (raw.includes("```")) {
            if (errorEl) errorEl.textContent = "Invalid JSON: remove markdown fences and paste only the JSON object.";
          } else {
            if (errorEl) errorEl.textContent = "Invalid JSON: " + err.message;
          }
          if (previewEl) previewEl.textContent = "{}";
          if (submitBtn) submitBtn.disabled = true;
          return { ok: false, rule: null };
        }
        const normalized = normalizeRule(parsed);
        const validationError = validateRule(normalized);
        if (validationError) {
          if (errorEl) errorEl.textContent = validationError;
          if (previewEl) previewEl.textContent = "{}";
          if (submitBtn) submitBtn.disabled = true;
          return { ok: false, rule: null };
        }
        const canonical = canonicalizeRule(normalized);
        if (errorEl) errorEl.textContent = "";
        if (previewEl) previewEl.textContent = JSON.stringify(canonical, null, 2);
        if (nameEl) nameEl.value = deriveRuleName(canonical);
        if (submitBtn) submitBtn.disabled = false;
        return { ok: true, rule: canonical };
      }

      let copyResetTimer = null;
      function setCopyButtonLabel(label) {
        if (!copySpecBtn) return;
        copySpecBtn.textContent = label;
        if (copyResetTimer) {
          window.clearTimeout(copyResetTimer);
        }
        copyResetTimer = window.setTimeout(function() {
          copySpecBtn.textContent = "Copy spec";
        }, 1500);
      }

      function copySpecText() {
        if (!specEl) return;
        const text = specEl.value || "";
        if (!text) return;
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(function() {
            setCopyButtonLabel("Copied");
          }).catch(function() {
            specEl.focus();
            specEl.select();
            const copied = document.execCommand("copy");
            setCopyButtonLabel(copied ? "Copied" : "Copy failed");
          });
          return;
        }
        specEl.focus();
        specEl.select();
        const copied = document.execCommand("copy");
        setCopyButtonLabel(copied ? "Copied" : "Copy failed");
      }

      if (specEl) {
        specEl.value = buildSpecText();
      }
      if (copySpecBtn) {
        copySpecBtn.addEventListener("click", copySpecText);
      }
      if (jsonInputEl) {
        jsonInputEl.addEventListener("input", renderValidation);
      }
      formEl.addEventListener("submit", function(event) {
        const result = renderValidation();
        if (!result.ok) {
          event.preventDefault();
          return;
        }
        if (jsonInputEl) {
          jsonInputEl.value = JSON.stringify(result.rule);
        }
      });
      renderValidation();
    })();
  </script>
{{end}}
