package maps

import (
	"encoding/json"
	"errors"
	"math"
	"os"
)

// RecordingMock replays a recorded Overpass response file for NearbyFeatures.
type RecordingMock struct {
	Stops []RecordedStop
}

type RecordedStop struct {
	Lat      float64   `json:"lat"`
	Lon      float64   `json:"lon"`
	Features []Feature `json:"nearby_features"`
}

type recordingFile struct {
	Stops []RecordedStop `json:"stops"`
}

// LoadRecordingMock loads a recording file generated by the Overpass recorder test.
func LoadRecordingMock(path string) (*RecordingMock, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	var rec recordingFile
	if err := json.Unmarshal(data, &rec); err != nil {
		return nil, err
	}
	if len(rec.Stops) == 0 {
		return nil, errors.New("recording has no stops")
	}
	return &RecordingMock{Stops: rec.Stops}, nil
}

// NearbyFeatures returns features for the closest recorded stop within a tolerance.
func (m *RecordingMock) NearbyFeatures(lat, lon float64) ([]Feature, error) {
	const tolMeters = 30.0
	bestIdx := -1
	bestDist := tolMeters
	for i, s := range m.Stops {
		d := haversineMeters(lat, lon, s.Lat, s.Lon)
		if d < bestDist {
			bestDist = d
			bestIdx = i
		}
	}
	if bestIdx == -1 {
		return nil, nil
	}
	return m.Stops[bestIdx].Features, nil
}

// haversineMeters computes distance between two lat/lon points.
func haversineMeters(lat1, lon1, lat2, lon2 float64) float64 {
	const R = 6371000.0
	toRad := func(deg float64) float64 { return deg * (math.Pi / 180.0) }
	dLat := toRad(lat2 - lat1)
	dLon := toRad(lon2 - lon1)
	lat1R := toRad(lat1)
	lat2R := toRad(lat2)
	a := math.Sin(dLat/2)*math.Sin(dLat/2) + math.Sin(dLon/2)*math.Sin(dLon/2)*math.Cos(lat1R)*math.Cos(lat2R)
	c := 2 * math.Atan2(math.Sqrt(a), math.Sqrt(1-a))
	return R * c
}
